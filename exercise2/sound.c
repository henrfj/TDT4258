#include "sound.h"

/*
 * The header containing songs is generated by a python script in
 * `midi/midi_parser.py`, the script takes any midi file and creates
 * the necessary arrays for each file out of it. It can also generate
 * the macro used to select the array based on the id (`SONG(id)`)
 * Each song is transformed in 3 arrays: the one containing all the
 * notes frequencies (float parsed with the macros in sound.h),
 * the one containing the duration of each note (used to scale) and
 * the one containing the relative amplitudes, used to give a little
 * more depth in the sound.
 */
#include "songs.h"

/*
 * This function can have multiple behaviours depending on the mode
 * with which it's called, this is required to access static
 * variables without requiring them to be global
 * If called with NO_CHANGE, it simply represents one period of
 * the note, based on the duration of it, the next note in the 
 * song itself can be set
 * If called with other values, the mode is used as song id and
 * a new song is selected (unless the id coincides to the current
 * song), this mode is called from the GPIO buttons
 */
int play_song(int mode)
{

	static uint8_t current_song_id = 0;
	static uint16_t i = 1;	//index of array in the song
	static uint16_t timer = 0;	//Return changing note counter
	uint8_t ret = GO_ON;

	// Soundmode, playing music
	if (mode == NO_CHANGE) {

		float frequency = SONG(current_song_id)[i];
		uint8_t ampl = SONG_AMPL(current_song_id)[i];
		uint8_t speed = SONG_SPD(current_song_id)[i];

		/*
		 * the timer variable keeps track on how long the note has
		 * been playing, since the board's timer is set to vibrate
		 * with the note's frequency, the duration of timer depends
		 * on it (defined with the GET_DURATION, more in the header)
		 * in the beginning of a note, it's frequency is set to the
		 * timer, so that the produced sound matches it. When the
		 * expected duration has been reached, the next note is
		 * selected or the playback is stopped if the song is over.
		 */
		if (timer == 1) {
			SET_FREQ(frequency);	//set the new frequency on the timer
			get_set_amplitude(GET_AMPL(ampl));
		} else if (timer > GET_DURATION(frequency, speed)) {
			timer = 0;
			i++;
			//the length of the array is saved in its first element
			int len = SONG(current_song_id)[0];
			if (i > len) {
				i = 1;
				ret = STOP_HERE;
			}
		}

		timer++;

		/*
		 * if the song is over, the return a different value to
		 * stop the timer from the IRQ handler itself. That cannot
		 * be done here as the interrupt request needs to be cleared
		 * before (and that's done in the handler)
		 */
		return ret;
	}
	/*
	 * Setting the id of the new song, reset the index if changing,
	 * otherwise go on playing (e.g. restart where it was if paused)
	 */
	if (mode > NO_CHANGE) {
		if (current_song_id != mode) {
			i = 1;
			timer = 0;
		}
		current_song_id = mode;
	}

	return 1;

}

int get_set_amplitude(int mode)
{
	static int amp = BASE_AMPL;

	if (mode == NO_CHANGE) {
		return amp;
	}

	return amp = mode;
}

/*
 * Called by the button's IRQ, based on the button pressed it either
 * pauses the music or starts a new tone, if the tone is the same that
 * have been paused it is continued from where it was stopped.
 * Play and pause functionalities are implemented through clock gating
 * of the timer module's clock (check their definition in the header)
 */
void read_button_value(int button_value)
{
	if (button_value == LEFT) {
		//un-gate the timer module and play a tune
		PLAY();
		play_song(NEW_TONE(0));
	} else if (button_value == UPL) {
		//un-gate the timer module and play a tune
		PLAY();
		play_song(NEW_TONE(1));
	} else if (button_value == RIGHTL) {
		//un-gate the timer module and play a tune
		PLAY();
		play_song(NEW_TONE(2));
	} else if (button_value == DOWNL) {
		//Clock gating the timer module (turns off sound)
		PAUSE();
	} else if (button_value == LEFTR) {
		//un-gate the timer module and play a tune
		PLAY();
		play_song(NEW_TONE(3));
	} else if (button_value == UPR) {
		//un-gate the timer module and play a tune
		PLAY();
		play_song(NEW_TONE(4));
	} else if (button_value == RIGHT) {
		//un-gate the timer module and play a tune
		PLAY();
		play_song(NEW_TONE(5));
	} else if (button_value == DOWNR) {
		//un-gate the timer module and play a tune
		PLAY();
		play_song(NEW_TONE(6));
	}
}

// POLLING UNDER HERE

/*
 * Same functions as above but implemented to work with polling,
 * no pause button is implemented as the timer is not actually used.
 * The frequencies and notes durations are instead implemented by
 * using a busy waiting approach.
 */

void polling_solution()
{
	int button_value = 0xff;
	while (1) {		//Polling forever
		button_value = *GPIO_PC_DIN;
		if (button_value == LEFT) {
			polling_play_sound(0);
		} else if (button_value == UPL) {
			polling_play_sound(1);
		} else if (button_value == RIGHTL) {
			polling_play_sound(2);
		} else if (button_value == DOWNL) {
			__asm__("nop");
		} else if (button_value == LEFTR) {
			polling_play_sound(3);
		} else if (button_value == UPR) {
			polling_play_sound(4);
		} else if (button_value == RIGHT) {
			polling_play_sound(5);
		} else if (button_value == DOWNR) {
			polling_play_sound(6);
		}

	}

}

void polling_play_sound(int current_song_id)
{
	int len = SONG(current_song_id)[0];
	float frequency;
	uint8_t ampl;
	uint8_t amplitude;
	uint8_t speed;
	float period;
	double duration;
	double compond_timer;

	for (int i = 1; i < len + 1; i++) {
		//get frequency
		frequency = SONG(current_song_id)[i];
		period = 1.0 / (frequency);	//in seconds

		//get amplitude
		ampl = SONG_AMPL(current_song_id)[i];
		amplitude = GET_AMPL(ampl);	//amplitude is way too low

		//get duration. "1/speed" is no. 1/16 of a beat
		speed = SONG_SPD(current_song_id)[i];
		duration = (BEAT / speed) * frequency;	//duration in num_periods

		//duration = (BEAT / speed); //duration in seconds (BEAT = seconds/beat)
		//clk_duration = duration * CPU_FREQ; // should be multiplied by CPU_FREQ

		compond_timer = 0;
		while (compond_timer < duration) {
			polling_one_period(amplitude, period);
			compond_timer++;
		}
	}

}

/*
 * Single tick of a note, implementing the same square wave using
 * busy waiting
 */
void polling_one_period(uint8_t amplitude, float period)
{
	*DAC0_CH0DATA = amplitude;
	*DAC0_CH1DATA = amplitude;
	my_sleep_2(period / 2);
	*DAC0_CH0DATA = 0x000;
	*DAC0_CH1DATA = 0x000;
	my_sleep_2(period / 2);
}

void test_timer()
{
	//Find the scalar for timer 2
	int button_value;
	while (1) {
		button_value = *GPIO_PC_DIN;
		if (button_value == LEFT) {
			my_sleep_2(2);
		}
		polling_one_period(0x5f, 0.005);

	}
}

void my_sleep_1(float secs)
{
	//Uses timer module timer to sleep.
	//Haven't worked so far.
}

/*
 * Sleep functionality implemented using busy wait,
 * many clock cycles are used for each iteration and so an
 * empirical scalar value is used to ensure the (almost) correct
 * correspondence between iterations and input seconds
 */
void my_sleep_2(float secs)
{
	//TODO: test accuracy of sleep
	float scalar = 11.5;
	float scaled = secs / scalar;
	int roof = scaled * CPU_FREQ;	//#Cycles to reach "secs"
	int i = 0;
	while (i < roof) {
		__asm__("nop");
		i++;
	}
}
